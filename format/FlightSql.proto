/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";
import "google/protobuf/descriptor.proto";

option java_package = "org.apache.arrow.flight.sql.impl";
package arrow.flight.protocol.sql;

/*
 * Represents a metadata request. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the metadata request.
 *
 * The returned schema will be:
 * <
 *  info_name: uint32 not null,
 *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int128_bitmask: int128>
 * >
 * where there is one row per requested piece of metadata information.
 */
message CommandGetSqlInfo {
  option (experimental) = true;

  /*
   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide
   * Flight SQL clients with basic, SQL syntax and SQL functions related information.
   * More information types can be added in future releases.
   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.
   *
   * Note that the set of metadata may expand.
   *
   * Initially, Flight SQL will support the following information types:
   * - Server Information - Range [0-500)
   * - Syntax Information - Range [500-1000)
   * Range [0-10,000) is reserved for defaults (see SqlInfo enum for default options). 
   * Custom options should start at 10,000.
   *
   * If omitted, then all metadata will be retrieved.
   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must
   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.
   * If additional metadata is included, the metadata IDs should start from 10,000.
   */
  repeated uint32 info = 1;
}

// Options for CommandGetSqlInfo.
enum SqlInfo {

  // Server Information [0-500): Provides basic information about the Flight SQL Server.

  /*
   * The name of the Flight SQL Server.
   */
  FLIGHT_SQL_SERVER_NAME = 0;

  /*
   * The native version of the Flight SQL Server.
   */
  FLIGHT_SQL_SERVER_VERSION = 1;

  /*
   * The Arrow format version of the Flight SQL Server.
   */
  FLIGHT_SQL_SERVER_ARROW_VERSION = 2;

  /* 
   * Indicates whether the Flight SQL Server is read only.
   *
   * Returns:
   * 0 - if read-write
   * 1 - if read only
   */
  FLIGHT_SQL_SERVER_READ_ONLY = 3;


  // SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.

  /*
   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.
   *
   * Returns:
   * - 0: if it doesn't support CREATE and DROP of catalogs.
   * - 1: if it supports CREATE and DROP of catalogs.
   */
  SQL_DDL_CATALOG = 500;

  /*
   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.
   *
   * Returns:
   * - 0: if it doesn't support CREATE and DROP of schemas.
   * - 1: if it supports CREATE and DROP of schemas.
   */
  SQL_DDL_SCHEMA = 501;

  /*
   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.
   *
   * Returns:
   * - 0: if it doesn't support CREATE and DROP of tables.
   * - 1: if it supports CREATE and DROP of tables.
   */
  SQL_DDL_TABLE = 502;

  /*
   * Indicates the case sensitivity of catalog, table and schema names.
   *
   * Returns:
   * - "CASE_INSENSITIVE"
   * - "UPPERCASE"
   * - "LOWERCASE"
   * - "UNKNOWN"
   */
  SQL_IDENTIFIER_CASE = 503;

  /*
   * Indicates the supported character(s) used to surround a delimited identifier.
   */
  SQL_IDENTIFIER_QUOTE_CHAR = 504;

  /*
   * Indicates case sensitivity of quoted identifiers.
   *
   * Returns:
   * - "CASE_INSENSITIVE"
   * - "UPPERCASE"
   * - "LOWERCASE"
   * - "UNKNOWN"
   */
  SQL_QUOTED_IDENTIFIER_CASE = 505;

  /*
   * Retrieves whether all tables are selectable.
   *
   * Returns:
   * - 0: if not all tables are selectable or if none are;
   * - 1: if all tables are selectable.
   */
  SQL_ALL_TABLES_ARE_SELECTABLE = 506;

  /*
   * Retrieves the null ordering.
   *
   * Returns a uint32 ordinal for the null ordering being used, as described in
   * `arrow.flight.protocol.sql.SqlNullOrdering`.
   */
  SQL_NULL_ORDERING = 507;

  /*
   * Retrieves the supported SQL keywords.
   *
   * Returns an int128 bitmask value representing the supported SQL keywords.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no SQL keyword is supported);
   * - return 1 (\b1)   => [SQL_NUMERIC_FUNCTION_ABS];
   * - return 2 (\b10)  => [SQL_NUMERIC_FUNCTION_ACOS];
   * - return 3 (\b11)  => [SQL_NUMERIC_FUNCTION_ABS, SQL_NUMERIC_FUNCTION_ACOS];
   * - return 4 (\b100) => [SQL_NUMERIC_FUNCTION_ATAN];
   * - ...
   * Valid SQL keywords are described under `arrow.flight.protocol.sql.SqlSupportedKeyword`.
   */
  SQL_SUPPORTED_KEYWORDS = 508;

  /*
   * Retrieves the supported SQL numeric functions.
   *
   * Returns an int128 bitmask value representing the supported SQL numeric functions.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no SQL numeric function is supported);
   * - return 1 (\b1)   => [SQL_NUMERIC_FUNCTION_ABS];
   * - return 2 (\b10)  => [SQL_NUMERIC_FUNCTION_ACOS];
   * - return 3 (\b11)  => [SQL_NUMERIC_FUNCTION_ABS, SQL_NUMERIC_FUNCTION_ACOS];
   * - return 4 (\b100) => [SQL_NUMERIC_FUNCTION_ATAN];
   * - ...
   * Valid SQL numeric functions are described under `arrow.flight.protocol.sql.SqlSupportedNumericFunction`.
   */
  SQL_SUPPORTED_NUMERIC_FUNCTIONS = 509;

  /*
   * Retrieves the supported SQL string functions.
   *
   * Returns an int128 bitmask value representing the supported SQL string functions.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no SQL string function is supported);
   * - return 1 (\b1)   => [SQL_STRING_FUNCTION_ASCII];
   * - return 2 (\b10)  => [SQL_STRING_FUNCTION_BIN];
   * - return 3 (\b11)  => [SQL_STRING_FUNCTION_ASCII, SQL_STRING_FUNCTION_BIN];
   * - return 4 (\b100) => [SQL_STRING_FUNCTION_BIT_LENGTH];
   * - ...
   * Valid SQL string functions are described under `arrow.flight.protocol.sql.SqlSupportedStringFunction`.
   */
  SQL_SUPPORTED_STRING_FUNCTIONS = 510;

  // Retrieves a comma-separated list of the available system functions.
  SQL_SUPPORTED_SYSTEM_FUNCTIONS = 511;

  /*
   * Retrieves the supported SQL datetime functions.
   *
   * Returns an int128 bitmask value representing the supported SQL datetime functions.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no SQL datetime function is supported);
   * - return 1 (\b1)   => [SQL_DATETIME_ADDDATE];
   * - return 2 (\b10)  => [SQL_DATETIME_ADDTIME];
   * - return 3 (\b11)  => [SQL_DATETIME_ADDDATE, SQL_DATETIME_ADDTIME];
   * - return 4 (\b100) => [SQL_DATETIME_CURDATE];
   * - ...
   * Valid SQL datetime functions are described under `arrow.flight.protocol.sql.SqlSupportedDatetimeFunction`.
   */
  SQL_SUPPORTED_DATETIME_FUNCTIONS = 512;

  /*
   * Retrieves the string that can be used to escape wildcard characters.
   * This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
   * (and therefore use one of the wildcard characters).
   * The '_' character represents any single character; the '%' character represents any sequence of zero or more
   * characters.
   */
  SQL_SEARCH_STRING_ESCAPE = 513;

  /*
   * Retrieves all the "extra" characters that can be used in unquoted identifier names
   * (those beyond a-z, A-Z, 0-9 and _).
   */
  SQL_EXTRA_NAME_CHARACTERS = 514;

  /*
   * Retrieves whether column aliasing is supported.
   * If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
   * as required.
   *
   * Returns:
   * - 0: if column aliasing is unsupported;
   * - 1: if column aliasing is supported.
   */
  SQL_SUPPORTS_COLUMN_ALIASING = 515;

  // Retrieves whether concatenations between null and non-null values being null are supported.
  SQL_NULL_PLUS_NULL_IS_NULL = 516;

  /*
   * Retrieves the supported SQL conversion functions.
   *
   * Returns an int128 bitmask value representing the supported SQL conversion functions.
   * The returned bitmask should be parsed in order to retrieve the supported SQL conversion functions.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no SQL conversion function is supported);
   * - return 1 (\b1)   => [SQL_CONVERSION_CAST];
   * - return 2 (\b10)  => [SQL_CONVERSION_CONVERT];
   * - return 3 (\b11)  => [SQL_CONVERSION_CAST, SQL_CONVERSION_CONVERT].
   * Valid SQL conversion functions are described under `arrow.flight.protocol.sql.SqlSupportedConversionFunction`.
   */
  SQL_SUPPORTED_CONVERSION_FUNCTIONS = 517;

  /*
   * Retrieves whether, when table correlation names are supported, they are restricted to being different
   * from the names of the tables.
   *
   * Returns:
   * - 0: if table correlation names are unsupported;
   * - 1: if table correlation names are supported.
   */
  SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518;

  /*
   * Retrieves whether, when table correlation names are supported, they are restricted to being different
   * from the names of the tables.
   *
   * Returns:
   * - 0: if different table correlation names are unsupported;
   * - 1: if different table correlation names are supported
   */
  SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519;

  /*
   * Retrieves whether expressions in ORDER BY lists are supported.
   *
   * Returns:
   * - 0: if expressions in ORDER BY are unsupported;
   * - 1: if expressions in ORDER BY are supported;
   */
  SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520;

  /*
   * Retrieves whether using a column that is not in the SELECT statement in a GROUP BY clause is supported.
   *
   * Returns:
   * - 0: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
   * - 1: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
   */
  SQL_SUPPORTS_ORDER_BY_UNRELATED = 521;

  /*
   * Retrieves the supported GROUP BY commands;
   *
   * Returns an int128 bitmask value representing the supported commands.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (GROUP BY is unsupported);
   * - return 1 (\b1)   => [SQL_GROUP_BY_UNRELATED];
   * - return 2 (\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
   * - return 3 (\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
   * Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
   */
  SQL_SUPPORTED_GROUP_BY = 522;

  /*
   * Retrieves whether specifying a LIKE escape clause is supported.
   *
   * Returns:
   * - 0: if specifying a LIKE escape clause is unsupported;
   * - 1: if specifying a LIKE escape clause is supported.
   */
  SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523;

  // Retrieves whether columns may be defined as non-nullable.
  SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524;

  /*
   * Retrieves the supported SQL grammar level as per the ODBC specification.
   *
   * Returns an int128 bitmask value representing the supported SQL grammar level.
   * The returned bitmask should be parsed in order to retrieve the supported grammar levels.
   *
   * For instance:
   * - return 0 (\b0)   => [] (SQL grammar is unsupported);
   * - return 1 (\b1)   => [SQL_MINIMUM_GRAMMAR];
   * - return 2 (\b10)  => [SQL_CORE_GRAMMAR];
   * - return 3 (\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
   * - return 4 (\b100) => [SQL_EXTENDED_GRAMMAR];
   * - return 5 (\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
   * - return 6 (\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
   * - return 7 (\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
   * Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
   */
  SQL_SUPPORTED_GRAMMAR = 525;

  /*
   * Retrieves the supported ANSI92 SQL grammar level.
   *
   * Returns an int128 bitmask value representing the supported ANSI92 SQL grammar level.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (ANSI92 SQL grammar is unsupported);
   * - return 1 (\b1)   => [ANSI92_ENTRY_SQL];
   * - return 2 (\b10)  => [ANSI92_INTERMEDIATE_SQL];
   * - return 3 (\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
   * - return 4 (\b100) => [ANSI92_FULL_SQL];
   * - return 5 (\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
   * - return 6 (\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
   * - return 7 (\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
   * Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
   */
  SQL_ANSI92_SUPPORTED_LEVEL = 526;

  // Retrieves whether the SQL Integrity Enhancement Facility is supported.
  SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527;

  /*
   * Retrieves the support level for SQL JOINs.
   *
   * Returns a uint32 ordinal for the SQL ordering being used, as described in
   * `arrow.flight.protocol.sql.SqlJoinsSupportLevel`.
   */
  SQL_JOINS_SUPPORT_LEVEL = 528;

  // Retrieves the preferred term for "schema".
  SQL_SCHEMA_TERM = 529;

  // Retrieves the preferred term for "procedure".
  SQL_PROCEDURE_TERM = 530;

  // Retrieves the preferred term for "catalog".
  SQL_CATALOG_TERM = 531;

  // Retrieves whether a catalog appears at the start of a fully qualified table name.
  SQL_CATALOG_AT_START = 532;

  /*
   * Retrieves the supported actions for a SQL schema.
   *
   * Returns an int128 bitmask value representing the supported actions for a SQL schema.
   * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported actions for SQL schema);
   * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
   * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
   * Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
   */
  SQL_SCHEMAS_SUPPORTED_ACTIONS = 533;

  /*
   * Retrieves the supported actions for a SQL schema.
   *
   * Returns an int128 bitmask value representing the supported actions for a SQL catalog.
   * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported actions for SQL catalog);
   * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
   * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
   * Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
   */
  SQL_CATALOGS_SUPPORTED_ACTIONS = 534;

  /*
   * Retrieves the supported SQL positioned commands.
   *
   * Returns an int128 bitmask value representing the supported SQL positioned commands.
   * The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported SQL positioned commands);
   * - return 1 (\b1)   => [SQL_POSITIONED_DELETE];
   * - return 2 (\b10)  => [SQL_POSITIONED_UPDATE];
   * - return 3 (\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
   */
  SQL_SUPPORTED_POSITIONED_COMMANDS = 535;

  // Retrieves whether SELECT FOR UPDATE statements are supported.
  SQL_SELECT_FOR_UPDATE_SUPPORTED = 536;

  // Retrieves whether stored procedure calls that use the stored procedure escape syntax are supported.
  SQL_STORED_PROCEDURES_SUPPORTED = 537;

  /*
   * Retrieves the supported SQL subqueries.
   *
   * Returns an int128 bitmask value representing the supported SQL subqueries.
   * The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported SQL subqueries);
   * - return 1   (\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
   * - return 2   (\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
   * - return 3   (\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
   * - return 4   (\b100)   => [SQL_SUBQUERIES_IN_INS];
   * - return 5   (\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
   * - return 6   (\b110)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
   * - return 7   (\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
   * - return 8   (\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 9   (\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 10  (\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 11  (\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 12  (\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 13  (\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 14  (\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 15  (\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - ...
   * Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
   */
  SQL_SUPPORTED_SUBQUERIES = 538;

  // Retrieves whether correlated subqueries are supported.
  SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539;

  /*
   * Retrieves the supported SQL UNIONs.
   *
   * Returns an int128 bitmask value representing the supported SQL UNIONs.
   * The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported SQL positioned commands);
   * - return 1 (\b1)   => [SQL_UNION];
   * - return 2 (\b10)  => [SQL_UNION_ALL];
   * - return 3 (\b11)  => [SQL_UNION, SQL_UNION_ALL].
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
   */
  SQL_SUPPORTED_UNIONS = 540;

  // Retrieves the maximum number of hex characters allowed in an inline binary literal.
  SQL_MAX_BINARY_LITERAL_LENGTH = 541;

  // Retrieves the maximum number of characters allowed for a character literal.
  SQL_MAX_CHAR_LITERAL_LENGTH = 542;

  // Retrieves the maximum number of characters allowed for a column name.
  SQL_MAX_COLUMN_NAME_LENGTH = 543;

  // Retrieves the maximum number of columns allowed in a GROUP BY clause.
  SQL_MAX_COLUMNS_IN_GROUP_BY = 544;

  // Retrieves the maximum number of columns allowed in an index.
  SQL_MAX_COLUMNS_IN_INDEX = 545;

  // Retrieves the maximum number of columns allowed in an ORDER BY clause.
  SQL_MAX_COLUMNS_IN_ORDER_BY = 546;

  // Retrieves the maximum number of columns allowed in a SELECT list.
  SQL_MAX_COLUMNS_IN_SELECT = 547;

  // Retrieves the maximum number of columns allowed in a table.
  SQL_MAX_COLUMNS_IN_TABLE = 548;

  // Retrieves the maximum number of concurrent connections possible.
  SQL_MAX_CONNECTIONS = 549;

  // Retrieves the maximum number of characters allowed in a cursor name.
  SQL_MAX_CURSOR_NAME_LENGTH = 550;

  // Retrieves the maximum number of bytes allowed for an index, including all of the parts of the index.
  SQL_MAX_INDEX_LENGTH = 551;

  // Retrieves the maximum number of characters allowed in a procedure name.
  SQL_SCHEMA_NAME_LENGTH = 552;

  // Retrieves the maximum number of bytes allowed in a single row.
  SQL_MAX_PROCEDURE_NAME_LENGTH = 553;

  // Retrieves the maximum number of characters allowed in a catalog name.
  SQL_MAX_CATALOG_NAME_LENGTH = 554;

  // Retrieves the maximum number of bytes allowed in a single row.
  SQL_MAX_ROW_SIZE = 555;

  /*
   * Retrieves whether the return value for the method getMaxRowSize includes the SQL data types
   * LONGVARCHAR and LONGVARBINARY.
   */
  SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556;

  /*
   * The maximum number of characters allowed for an SQL statement;
   * a result of zero means that there is no limit or the limit is not known.
   */
  SQL_MAX_STATEMENT_LENGTH = 557;

  // Retrieves the maximum number of active statements to this database that can be open at the same time.
  SQL_MAX_STATEMENTS = 558;

  // Retrieves the maximum number of characters allowed in a table name.
  SQL_MAX_TABLE_NAME_LENGTH = 559;

  // Retrieves the maximum number of tables allowed in a SELECT statement.
  SQL_MAX_TABLES_IN_SELECT = 560;

  // Retrieves the maximum number of characters allowed in a user name.
  SQL_MAX_USERNAME_LENGTH = 561;

  /*
   * Retrieves this database's default transaction isolation level as described in
   * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
   *
   * Returns an ordinal for the SQL transaction isolation level.
   */
  SQL_DEFAULT_TRANSACTION_ISOLATION = 562;

  /*
   * Retrieves whether transactions are supported. If not, invoking the method commit is a noop,
   * and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
   *
   * Returns:
   * - 0: if transactions are unsupported;
   * - 1: if transactions are supported.
   */
  SQL_TRANSACTIONS_SUPPORTED = 563;

  /*
   * Retrieves the supported transactions isolation levels.
   *
   * Returns an int128 bitmask value representing the supported transactions isolation levels.
   * The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported SQL transactions isolation levels);
   * - return 1   (\b1)     => [SQL_TRANSACTION_NONE];
   * - return 2   (\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
   * - return 3   (\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
   * - return 4   (\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
   * - return 5   (\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 6   (\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 7   (\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 8   (\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
   * - return 9   (\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 10  (\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 11  (\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 12  (\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 13  (\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 14  (\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 15  (\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 16  (\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
   * - ...
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
   */
  SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564;

  /*
   * Retrieves whether a data definition statement within a transaction forces the transaction to commit.
   *
   * Returns:
   * - 0: if a data definition statement within a transaction does not force the transaction to commit;
   * - 1: if a data definition statement within a transaction forces the transaction to commit.
   */
  SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565;

  /*
   * Retrieves whether a data definition statement within a transaction is ignored.
   *
   * Returns:
   * - 0: if a data definition statement within a transaction is taken into account;
   * - 1: a data definition statement within a transaction is ignored.
   */
  SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566;

  /*
   * Retrieves an int128 bitmask value representing the supported result set types.
   * The returned bitmask should be parsed in order to retrieve the supported result set types.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported result set types);
   * - return 1   (\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
   * - return 2   (\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
   * - return 3   (\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
   * - return 4   (\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 5   (\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 6   (\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 7   (\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 8   (\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
   * - ...
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
   */
  SQL_SUPPORTED_RESULT_SET_TYPES = 567;

  /*
   * Returns an int128 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568;

  /*
   * Returns an int128 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569;

  /*
   * Returns an int128 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570;

  /*
   * Returns an int128 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571;

  /*
   * Retrieves whether this database supports batch updates.
   *
   * - 0: if this database does not support batch updates;
   * - 1: if this database supports batch updates.
   */
  SQL_BATCH_UPDATES_SUPPORTED = 572;

  /*
   * Retrieves whether this database supports savepoints.
   *
   * Returns:
   * - 0: if this database does not support savepoints;
   * - 1: if this database supports savepoints.
   */
  SQL_SAVEPOINTS_SUPPORTED = 573;

  /*
   * Retrieves whether named parameters are supported in callable statements.
   *
   * Returns:
   * - 0: if named parameters in callable statements are unsupported;
   * - 1: if named parameters in callable statements are supported.
   */
  SQL_NAMED_PARAMETERS_SUPPORTED = 574;

  /*
   * Indicates whether updates made to a LOB are made on a copy or directly to the LOB.
   *
   * Returns:
   * - 0: if updates made to a LOB are made directly to the LOB;
   * - 1: if updates made to a LOB are made on a copy.
   */
  SQL_LOCATORS_UPDATE_COPY = 575;

  /*
   * Retrieves whether invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
   *
   * Returns:
   * - 0: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
   * - 1: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
   */
  SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576;
}

// The sorting of null values.
enum SqlNullOrdering {
  // Null values are sorted at the end regardless of sort order.
  SQL_NULLS_SORTED_HIGH = 0;
  // Null values are sorted low.
  SQL_NULLS_SORTED_LOW = 1;
  // Null values are sorted at the start regardless of sort order.
  SQL_NULLS_SORTED_AT_START = 2;
  // Null values are sorted at the end regardless of sort order.
  SQL_NULLS_SORTED_AT_END = 3;
}

enum SupportedSqlGrammar {
  SQL_MINIMUM_GRAMMAR = 0;
  SQL_CORE_GRAMMAR = 1;
  SQL_EXTENDED_GRAMMAR = 2;
}

enum SupportedAnsi92SqlGrammarLevel {
  ANSI92_ENTRY_SQL = 0;
  ANSI92_INTERMEDIATE_SQL = 1;
  ANSI92_FULL_SQL = 2;
}

enum SqlJoinsSupportLevel {
  SQL_JOINS_UNSUPPORTED = 0;
  SQL_LIMITED_JOINS = 1;
  SQL_FULL_OUTER_JOINS = 2;
}

enum SqlSupportedGroupBy {
  SQL_GROUP_BY_UNRELATED = 0;
  SQL_GROUP_BY_BEYOND_SELECT = 1;
}

enum SqlSupportedElementActions {
  SQL_ELEMENT_IN_PROCEDURE_CALLS = 0;
  SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1;
  SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2;
}

enum SqlSupportedPositionedCommands {
  SQL_POSITIONED_DELETE = 0;
  SQL_POSITIONED_UPDATE = 1;
}

enum SqlSupportedSubqueries {
  SQL_SUBQUERIES_IN_COMPARISONS = 0;
  SQL_SUBQUERIES_IN_EXISTS = 1;
  SQL_SUBQUERIES_IN_INS = 2;
  SQL_SUBQUERIES_IN_QUANTIFIEDS = 3;
}

enum SqlSupportedUnions {
  SQL_UNION = 0;
  SQL_UNION_ALL = 1;
}

enum SqlTransactionIsolationLevel {
  SQL_TRANSACTION_NONE = 0;
  SQL_TRANSACTION_READ_UNCOMMITTED = 1;
  SQL_TRANSACTION_READ_COMMITTED = 2;
  SQL_TRANSACTION_REPEATABLE_READ = 3;
  SQL_TRANSACTION_SERIALIZABLE = 4;
}

enum SqlSupportedTransactions {
  SQL_TRANSACTION_UNSPECIFIED = 0;
  SQL_DATA_DEFINITION_TRANSACTIONS = 1;
  SQL_DATA_MANIPULATION_TRANSACTIONS = 2;
}

enum SqlSupportedResultSetType {
  SQL_RESULT_SET_TYPE_UNSPECIFIED = 0;
  SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1003;
  SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 1004;
  SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 1005;
}

enum SqlSupportedResultSetConcurrency {
  SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0;
  SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1;
  SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2;
}

enum SqlSupportedNumericFunction {
  SQL_NUMERIC_FUNCTION_ABS = 0;
  SQL_NUMERIC_FUNCTION_ACOS = 1;
  SQL_NUMERIC_FUNCTION_ASIN = 2;
  SQL_NUMERIC_FUNCTION_ATAN = 3;
  SQL_NUMERIC_FUNCTION_ATAN2 = 4;
  SQL_NUMERIC_FUNCTION_BIT_AND = 5;
  SQL_NUMERIC_FUNCTION_BIT_COUNT = 6;
  SQL_NUMERIC_FUNCTION_BIT_OR = 7;
  SQL_NUMERIC_FUNCTION_CEIL = 8;
  SQL_NUMERIC_FUNCTION_CEILING = 9;
  SQL_NUMERIC_FUNCTION_CONV = 10;
  SQL_NUMERIC_FUNCTION_COS = 11;
  SQL_NUMERIC_FUNCTION_COT = 12;
  SQL_NUMERIC_FUNCTION_DEGREES = 13;
  SQL_NUMERIC_FUNCTION_EXP = 14;
  SQL_NUMERIC_FUNCTION_FLOOR = 15;
  SQL_NUMERIC_FUNCTION_FORMAT = 16;
  SQL_NUMERIC_FUNCTION_GREATEST = 17;
  SQL_NUMERIC_FUNCTION_INTERVAL = 18;
  SQL_NUMERIC_FUNCTION_LEAST = 19;
  SQL_NUMERIC_FUNCTION_LOG = 20;
  SQL_NUMERIC_FUNCTION_LOG10 = 21;
  SQL_NUMERIC_FUNCTION_MOD = 22;
  SQL_NUMERIC_FUNCTION_OCT = 23;
  SQL_NUMERIC_FUNCTION_PI = 24;
  SQL_NUMERIC_FUNCTION_POW = 25;
  SQL_NUMERIC_FUNCTION_POWER = 26;
  SQL_NUMERIC_FUNCTION_RADIANS = 27;
  SQL_NUMERIC_FUNCTION_ROUND = 28;
  SQL_NUMERIC_FUNCTION_SIN = 29;
  SQL_NUMERIC_FUNCTION_SQRT = 30;
  SQL_NUMERIC_FUNCTION_STD = 31;
  SQL_NUMERIC_FUNCTION_STDDEV = 32;
  SQL_NUMERIC_FUNCTION_TAN = 33;
  SQL_NUMERIC_FUNCTION_TRUNCATE = 34;
}

enum SqlSupportedStringFunction {
  SQL_STRING_FUNCTION_ASCII = 0;
  SQL_STRING_FUNCTION_BIN = 1;
  SQL_STRING_FUNCTION_BIT_LENGTH = 2;
  SQL_STRING_FUNCTION_CHAR_LENGTH = 3;
  SQL_STRING_FUNCTION_CHAR = 4;
  SQL_STRING_FUNCTION_CHARACTER_LENGTH = 5;
  SQL_STRING_FUNCTION_CONCAT_WS = 6;
  SQL_STRING_FUNCTION_CONCAT = 7;
  SQL_STRING_FUNCTION_CONV = 8;
  SQL_STRING_FUNCTION_ELT = 9;
  SQL_STRING_FUNCTION_EXPORT_SET = 10;
  SQL_STRING_FUNCTION_FIELD = 11;
  SQL_STRING_FUNCTION_FIND_IN_SET = 12;
  SQL_STRING_FUNCTION_FORMAT = 13;
  SQL_STRING_FUNCTION_HEX = 14;
  SQL_STRING_FUNCTION_INSERT = 15;
  SQL_STRING_FUNCTION_INSTR = 16;
  SQL_STRING_FUNCTION_LCASE = 17;
  SQL_STRING_FUNCTION_LEFT = 18;
  SQL_STRING_FUNCTION_LENGTH = 19;
  SQL_STRING_FUNCTION_LOAD_FILE = 20;
  SQL_STRING_FUNCTION_LOCATE = 21;
  SQL_STRING_FUNCTION_LOWER = 22;
  SQL_STRING_FUNCTION_LPAD = 23;
  SQL_STRING_FUNCTION_LTRIM = 24;
  SQL_STRING_FUNCTION_MAKE_SET = 25;
  SQL_STRING_FUNCTION_MID = 26;
  SQL_STRING_FUNCTION_OCT = 27;
  SQL_STRING_FUNCTION_OCTET_LENGTH = 28;
  SQL_STRING_FUNCTION_ORD = 29;
  SQL_STRING_FUNCTION_POSITION = 30;
  SQL_STRING_FUNCTION_QUOTE = 31;
  SQL_STRING_FUNCTION_REGEXP = 32;
  SQL_STRING_FUNCTION_REPEAT = 33;
  SQL_STRING_FUNCTION_REPLACE = 34;
  SQL_STRING_FUNCTION_REVERSE = 35;
  SQL_STRING_FUNCTION_RIGHT = 36;
  SQL_STRING_FUNCTION_RPAD = 37;
  SQL_STRING_FUNCTION_RTRIM = 38;
  SQL_STRING_FUNCTION_SOUNDEX = 39;
  SQL_STRING_FUNCTION_SOUNDS_LIKE = 40;
  SQL_STRING_FUNCTION_SPACE = 41;
  SQL_STRING_FUNCTION_STRCMP = 42;
  SQL_STRING_FUNCTION_SUBSTRING_INDEX = 43;
  SQL_STRING_FUNCTION_SUBSTRING_SUBSTR = 44;
  SQL_STRING_FUNCTION_TRIM = 45;
  SQL_STRING_FUNCTION_UCASE = 46;
  SQL_STRING_FUNCTION_UNHEX = 47;
  SQL_STRING_FUNCTION_UPPER = 48;
}

enum SqlSupportedDatetimeFunction {
  SQL_DATETIME_ADDDATE = 0;
  SQL_DATETIME_ADDTIME = 1;
  SQL_DATETIME_CONVERT_TZ = 2;
  SQL_DATETIME_CURDATE = 3;
  SQL_DATETIME_CURRENT_DATE = 4;
  SQL_DATETIME_CURRENT_TIME = 5;
  SQL_DATETIME_CURRENT_TIMESTAMP = 6;
  SQL_DATETIME_CURTIME = 7;
  SQL_DATETIME_DATE_ADD = 8;
  SQL_DATETIME_DATE_FORMAT = 9;
  SQL_DATETIME_DATE_SUB = 10;
  SQL_DATETIME_DATE = 11;
  SQL_DATETIME_DATEDIFF = 12;
  SQL_DATETIME_DAY = 13;
  SQL_DATETIME_DAYNAME = 14;
  SQL_DATETIME_DAYOFMONTH = 15;
  SQL_DATETIME_DAYOFWEEK = 16;
  SQL_DATETIME_DAYOFYEAR = 17;
  SQL_DATETIME_EXTRACT = 18;
  SQL_DATETIME_FROM_DAYS = 19;
  SQL_DATETIME_FROM_UNIXTIME = 20;
  SQL_DATETIME_HOUR = 21;
  SQL_DATETIME_LAST_DAY = 22;
  SQL_DATETIME_LOCALTIME = 23;
  SQL_DATETIME_LOCALTIMESTAMP = 24;
  SQL_DATETIME_MAKEDATE = 25;
  SQL_DATETIME_MAKETIME = 26;
  SQL_DATETIME_MICROSECOND = 27;
  SQL_DATETIME_MINUTE = 28;
  SQL_DATETIME_MONTH = 29;
  SQL_DATETIME_MONTHNAME = 30;
  SQL_DATETIME_NOW = 31;
  SQL_DATETIME_PERIOD_ADD = 32;
  SQL_DATETIME_PERIOD_DIFF = 33;
  SQL_DATETIME_QUARTER = 34;
  SQL_DATETIME_SEC_TO_TIME = 35;
  SQL_DATETIME_SECOND = 36;
  SQL_DATETIME_STR_TO_DATE = 37;
  SQL_DATETIME_SUBDATE = 38;
  SQL_DATETIME_SUBTIME = 39;
  SQL_DATETIME_SYSDATE = 40;
  SQL_DATETIME_TIME_FORMAT = 41;
  SQL_DATETIME_TIME_TO_SEC = 42;
  SQL_DATETIME_TIME = 43;
  SQL_DATETIME_TIMEDIFF = 44;
  SQL_DATETIME_TIMESTAMP = 45;
  SQL_DATETIME_TIMESTAMPADD = 46;
  SQL_DATETIME_TIMESTAMPDIFF = 47;
  SQL_DATETIME_TO_DAYS = 48;
  SQL_DATETIME_UNIX_TIMESTAMP = 49;
  SQL_DATETIME_UTC_DATE = 50;
  SQL_DATETIME_UTC_TIME = 51;
  SQL_DATETIME_UTC_TIMESTAMP = 52;
  SQL_DATETIME_WEEK = 53;
  SQL_DATETIME_WEEKDAY = 54;
  SQL_DATETIME_WEEKOFYEAR = 55;
  SQL_DATETIME_YEAR = 56;
  SQL_DATETIME_YEARWEEK = 57;
}

enum SqlSupportedKeyword {
  SQL_KEYWORD_ADD = 0;
  SQL_KEYWORD_ADD_CONSTRAINT = 1;
  SQL_KEYWORD_ALTER = 2;
  SQL_KEYWORD_ALTER_COLUMN = 3;
  SQL_KEYWORD_ALTER_TABLE = 4;
  SQL_KEYWORD_ALL = 5;
  SQL_KEYWORD_AND = 6;
  SQL_KEYWORD_ANY = 7;
  SQL_KEYWORD_AS = 8;
  SQL_KEYWORD_ASC = 9;
  SQL_KEYWORD_BACKUP_DATABASE = 10;
  SQL_KEYWORD_BETWEEN = 11;
  SQL_KEYWORD_CASE = 12;
  SQL_KEYWORD_CHECK = 13;
  SQL_KEYWORD_COLUMN = 14;
  SQL_KEYWORD_CONSTRAINT = 15;
  SQL_KEYWORD_CREATE = 16;
  SQL_KEYWORD_CREATE_DATABASE = 17;
  SQL_KEYWORD_CREATE_INDEX = 18;
  SQL_KEYWORD_CREATE_OR_REPLACE_VIEW = 19;
  SQL_KEYWORD_CREATE_TABLE = 20;
  SQL_KEYWORD_CREATE_PROCEDURE = 21;
  SQL_KEYWORD_UNIQUE_INDEX = 22;
  SQL_KEYWORD_CREATE_VIEW = 23;
  SQL_KEYWORD_DATABASE = 24;
  SQL_KEYWORD_DEFAULT = 25;
  SQL_KEYWORD_DELETE = 26;
  SQL_KEYWORD_DESC = 27;
  SQL_KEYWORD_DISTINCT = 28;
  SQL_KEYWORD_DROP = 29;
  SQL_KEYWORD_DROP_COLUMN = 30;
  SQL_KEYWORD_DROP_CONSTRAINT = 31;
  SQL_KEYWORD_DROP_DATABASE = 32;
  SQL_KEYWORD_DROP_DEFAULT = 33;
  SQL_KEYWORD_DROP_INDEX = 34;
  SQL_KEYWORD_DROP_TABLE = 35;
  SQL_KEYWORD_DROP_VIEW = 36;
  SQL_KEYWORD_EXEC = 37;
  SQL_KEYWORD_EXISTS = 38;
  SQL_KEYWORD_FOREIGN_KEY = 39;
  SQL_KEYWORD_FROM = 40;
  SQL_KEYWORD_FULL_OUTER_JOIN = 41;
  SQL_KEYWORD_GROUP_BY = 42;
  SQL_KEYWORD_HAVING = 43;
  SQL_KEYWORD_IN = 44;
  SQL_KEYWORD_INDEX = 45;
  SQL_KEYWORD_INNER_JOIN = 46;
  SQL_KEYWORD_INSERT_INTO = 47;
  SQL_KEYWORD_INSERT_INTO_SELECT = 48;
  SQL_KEYWORD_IS_NULL = 49;
  SQL_KEYWORD_IS_NOT_NULL = 50;
  SQL_KEYWORD_JOIN = 51;
  SQL_KEYWORD_LEFT_JOIN = 52;
  SQL_KEYWORD_LIKE = 53;
  SQL_KEYWORD_LIMIT = 54;
  SQL_KEYWORD_NOT = 55;
  SQL_KEYWORD_NOT_NULL = 56;
  SQL_KEYWORD_OR = 57;
  SQL_KEYWORD_ORDER_BY = 58;
  SQL_KEYWORD_OUTER_JOIN = 59;
  SQL_KEYWORD_PRIMARY_KEY = 60;
  SQL_KEYWORD_PROCEDURE = 61;
  SQL_KEYWORD_RIGHT_JOIN = 62;
  SQL_KEYWORD_ROWNUM = 63;
  SQL_KEYWORD_SELECT = 64;
  SQL_KEYWORD_SELECT_DISTINCT = 65;
  SQL_KEYWORD_SELECT_INTO = 66;
  SQL_KEYWORD_SELECT_TOP = 67;
  SQL_KEYWORD_SET = 68;
  SQL_KEYWORD_TABLE = 69;
  SQL_KEYWORD_TOP = 70;
  SQL_KEYWORD_TRUNCATE_TABLE = 71;
  SQL_KEYWORD_UNION = 72;
  SQL_KEYWORD_UNION_ALL = 73;
  SQL_KEYWORD_UNIQUE = 74;
  SQL_KEYWORD_UPDATE = 75;
  SQL_KEYWORD_VALUES = 76;
  SQL_KEYWORD_VIEW = 77;
  SQL_KEYWORD_WHERE = 78;
}

enum SqlSupportedConversionFunction {
  SQL_CONVERSION_CAST = 0;
  SQL_CONVERSION_CONVERT = 1;
}

/*
 * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  catalog_name: utf8 not null
 * >
 * The returned data should be ordered by catalog_name.
 */
message CommandGetCatalogs {
  option (experimental) = true;
}

/*
 * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  catalog_name: utf8,
 *  schema_name: utf8 not null
 * >
 * The returned data should be ordered by catalog_name, then schema_name.
 */
message CommandGetSchemas {
  option (experimental) = true;

  /*
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  optional string catalog = 1;

  /*
   * Specifies a filter pattern for schemas to search for.
   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   */
  optional string schema_filter_pattern = 2;
}

/*
 * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  catalog_name: utf8,
 *  schema_name: utf8,
 *  table_name: utf8 not null,
 *  table_type: utf8 not null,
 *  [optional] table_schema: bytes not null (schema of the table as described in Schema.fbs::Schema,
 *                                           it is serialized as an IPC message.)
 * >
 * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type, followed by table_schema if requested.
 */
message CommandGetTables {
  option (experimental) = true;

  /*
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  optional string catalog = 1;

  /*
   * Specifies a filter pattern for schemas to search for.
   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   */
  optional string schema_filter_pattern = 2;

  /*
   * Specifies a filter pattern for tables to search for.
   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   */
  optional string table_name_filter_pattern = 3;

  // Specifies a filter of table types which must match.
  repeated string table_types = 4;

  // Specifies if the schema should be returned for found tables.
  bool include_schema = 5;
}

/*
 * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  table_type: utf8 not null
 * >
 * The returned data should be ordered by table_type.
 */
message CommandGetTableTypes {
  option (experimental) = true;
}

/*
 * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  catalog_name: utf8,
 *  schema_name: utf8,
 *  table_name: utf8 not null,
 *  column_name: utf8 not null,
 *  key_name: utf8,
 *  key_sequence: int not null
 * >
 * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.
 */
message CommandGetPrimaryKeys {
  option (experimental) = true;

  /*
   * Specifies the catalog to search for the table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  optional string catalog = 1;

  /*
   * Specifies the schema to search for the table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  optional string schema = 2;

  // Specifies the table to get the primary keys for.
  string table = 3;
}

/*
 * Represents a request to retrieve a description of the foreign key columns that reference the given table's
 * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint1 not null,
 *  delete_rule: uint1 not null
 * >
 * The returned data should be ordered by fk_catalog_name, fk_schema_name, fk_table_name, fk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions declared on UpdateDeleteRules enum.
 */
message CommandGetExportedKeys {
  option (experimental) = true;

  /*
   * Specifies the catalog to search for the foreign key table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  optional string catalog = 1;

  /*
   * Specifies the schema to search for the foreign key table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  optional string schema = 2;

  // Specifies the foreign key table to get the foreign keys for.
  string table = 3;
}

enum UpdateDeleteRules {
  CASCADE = 0;
  RESTRICT = 1;
  SET_NULL = 2;
  NO_ACTION = 3;
  SET_DEFAULT = 4;
}

/*
 * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint1 not null,
 *  delete_rule: uint1 not null
 * >
 * The returned data should be ordered by pk_catalog_name, pk_schema_name, pk_table_name, pk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions:
 *    - 0 = CASCADE
 *    - 1 = RESTRICT
 *    - 2 = SET NULL
 *    - 3 = NO ACTION
 *    - 4 = SET DEFAULT
 */
message CommandGetImportedKeys {
  option (experimental) = true;

  /*
   * Specifies the catalog to search for the primary key table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  optional string catalog = 1;

  /*
   * Specifies the schema to search for the primary key table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  optional string schema = 2;

  // Specifies the primary key table to get the foreign keys for.
  string table = 3;
}

// SQL Execution Action Messages

/*
 * Request message for the "CreatePreparedStatement" action on a Flight SQL enabled backend.
 */
message ActionCreatePreparedStatementRequest {
  option (experimental) = true;

  // The valid SQL string to create a prepared statement for.
  string query = 1;
}

/*
 * Wrap the result of a "GetPreparedStatement" action.
 *
 * The resultant PreparedStatement can be closed either:
 * - Manually, through the "ClosePreparedStatement" action;
 * - Automatically, by a server timeout.
 */
message ActionCreatePreparedStatementResult {
  option (experimental) = true;

  // Opaque handle for the prepared statement on the server.
  bytes prepared_statement_handle = 1;

  // If a result set generating query was provided, dataset_schema contains the 
  // schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.
  bytes dataset_schema = 2;

  // If the query provided contained parameters, parameter_schema contains the 
  // schema of the expected parameters as described in Schema.fbs::Schema, it is serialized as an IPC message.
  bytes parameter_schema = 3;
}

/*
 * Request message for the "ClosePreparedStatement" action on a Flight SQL enabled backend.
 * Closes server resources associated with the prepared statement handle.
 */
message ActionClosePreparedStatementRequest {
  option (experimental) = true;

  // Opaque handle for the prepared statement on the server.
  bytes prepared_statement_handle = 1;
}


// SQL Execution Messages.

/*
 * Represents a SQL query. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the query.
 */
message CommandStatementQuery {
  option (experimental) = true;

  // The SQL syntax.
  string query = 1;
}

/**
 * Represents a ticket resulting from GetFlightInfo with a CommandStatementQuery.
 * This should be treated as an opaque value, that is, clients should not attempt to parse this.
 */
message TicketStatementQuery {
  option (experimental) = true;

  // Unique identifier for the instance of the statement to execute.
  bytes statement_handle = 1;
}

/*
 * Represents an instance of executing a prepared statement. Used in the command member of FlightDescriptor for
 * the following RPC calls:
 *  - DoPut: bind parameter values. All of the bound parameter sets will be executed as a single atomic execution.
 *  - GetFlightInfo: execute the prepared statement instance.
 */
message CommandPreparedStatementQuery {
  option (experimental) = true;

  // Opaque handle for the prepared statement on the server.
  bytes prepared_statement_handle = 1;
}

/*
 * Represents a SQL update query. Used in the command member of FlightDescriptor
 * for the the RPC call DoPut to cause the server to execute the included SQL update.
 */
message CommandStatementUpdate {
  option (experimental) = true;

  // The SQL syntax.
  string query = 1;
}

/*
 * Represents a SQL update query. Used in the command member of FlightDescriptor
 * for the the RPC call DoPut to cause the server to execute the included 
 * prepared statement handle as an update.
 */
message CommandPreparedStatementUpdate {
  option (experimental) = true;

  // Opaque handle for the prepared statement on the server.
  bytes prepared_statement_handle = 1;
}

/*
 * Returned from the RPC call DoPut when a CommandStatementUpdate
 * CommandPreparedStatementUpdate was in the request, containing
 * results from the update. 
 */
message DoPutUpdateResult {
  option (experimental) = true;

  // The number of records updated. A return value of -1 represents 
  // an unknown updated record count.
  int64 record_count = 1;
}

extend google.protobuf.MessageOptions {
  bool experimental = 1000;
}
